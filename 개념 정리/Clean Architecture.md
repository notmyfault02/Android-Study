# Clean Architecture with Android

## 계층

### Entities

### Use Cases

### Interface Adapters

### Frameworks & Drivers

![clean architectureì ëí ì´ë¯¸ì§ ê²ìê²°ê³¼](http://blog.coderifleman.com/images/2017/the-clean-architecture/the-clean-architecture.jpg)



## 특징

### 프레임워크로부터 독립해라

* 아키텍쳐는 프레임워크에 의존하면 안된다. 새로운 프레임워크를 적용할 수 있어야 한다

### 세부 구현으로 부터 독립해라

* 소프트웨어 시스템의 핵심 모듈은 UI, 데이터베이스, 프레임워크, 라이브러리 등의 변경에 영향을 받지 않아야 한다.

### 의존성 규칙

* 내부 레이어는 상위/외부 레이어를 알아서는 안된다.
* 외부 레이어에서 선언한 함수, 클래스, 변수의 이름을 내부 레이어에서 참조해서는 안된다.
* 외부 레이어의 데이터 포맷을 내부 레이어에서 사용하면 안된다.
* 그 결과로 모든 의존성은 내부 레이어를 향해야 한다.

### 교차 경계

![image-20190823132246411](/Users/notmyfault02/Library/Application Support/typora-user-images/image-20190823132246411.png)

* 컨트롤러와 프리젠터가 다음 계층이 유스케이스와 대화하는 과정
* 제어의 흐름은 컨트롤러에서 시작해 유스케이스를 거쳐 프리젠터에서 실행된다.
* 의존성은 모두 안쪽의 유스케이스로 향하고 있다.
* 의존성 규칙으로 인해 유스케이스가 프리젠터를 호출 할 수 없지만, `의존성 역전의 법칙` 을 통해 해결이 가능하다.

### 의존성 역전의 법칙

* 동적인 다형성의 이점을 이용해 소스 코드의 의존성을 제어 흐름의 반대가 되도록 한다.
* 유스케이스는 안쪽 원의 인터페이스를 호출한다. 그리고 원 바깥쪽의 프리젠터는 인터페이스를 구현한다.
* 고수준의 모듈이 저수준 모듈에 의존성을 가지면 안된다.
* 양쪽 모듈 모두 추상화에 의존해야 한다.
* 세부 사항이 추상화된 모듈에 의존성을 가져야 한다.
* 

### Adapter 와 Converter의 필요성

* 각각의 레이어가 협력할 때, 레이어 내부의 세부 사항이 다른 레이어로 전파되지 않도록 하는 역할
* 각각의 레이어가 필요로 하는 데이터 모델을 외부 레이어로 전달하거나 외부 레이어에서 받아올 때 데이터 모델의 격리를 위해 데이터 모델을 다른 데이터 모델로 변환하는 역할

### 테스트의 용이성

* 비즈니스 규칙은 UI, 데이터베이스, 기타 요인에 얽메이지 않고 테스트가 가능함

### 

